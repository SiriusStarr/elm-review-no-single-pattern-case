[{"name":"NoSinglePatternCase","comment":"\n\n\n# Rule\n\n@docs rule\n\n\n# Config\n\n@docs Config, fixInArgument, fixInLet\n\n\n## Customizing Config Behavior\n\n@docs ifAsPatternRequired, ifArgumentNotDestructurable, ifNoLetExists\n\n\n## Config Behavior Options\n\nThese functions are simply used by\n[`ifAsPatternRequired`](#ifAsPatternRequired),\n[`ifArgumentNotDestructurable`](#ifArgumentNotDestructurable), and\n[`ifNoLetExists`](#ifNoLetExists) to customize behavior of the default configs\nand are (hopefully) self-explanatory.\n\n@docs fail, fixInLetInstead, butIfNoLetExists, creatingNewLetIfNecessary, useAsPatternInstead, butIfAsPatternRequired, createNewLetInstead, fixInArgumentInstead, usingAsPatternIfNecessary\n\n\n## Resolving Name Clashes\n\n@docs resolveNameClashWithSeparateLet\n\n","unions":[{"name":"Config","comment":" Configure the rule, determining how automatic fixes are generated.\n\nThe default `Config`s [`fixInArgument`](#fixInArgument) and\n[`fixInLet`](#fixInLet) should be used as reasonable defaults, with more\ncustomization detailed in those sections.\n\nAll methods of fixing can generate name clashes, as the scope of the name will\nnecessarily be larger. By default, such name clashes will not be automatically\nfixed (though `elm-review` errors will still be generated so they can be\nmanually resolved). They can, however, be automatically fixed by creating a\nseparate `let` block just to destructure the pattern in. Use\n[`resolveNameClashWithSeparateLet`](#resolveNameClashWithSeparateLet) if this\nbehavior is desired.\n\n","args":["fixBy"],"cases":[]}],"aliases":[],"values":[{"name":"butIfAsPatternRequired","comment":" If an `as` pattern would be necessary, choose some other behavior instead.\n","type":"NoSinglePatternCase.FixOrFallback NoSinglePatternCase.CreateNewLet NoSinglePatternCase.Fail -> (NoSinglePatternCase.FixOrFallback NoSinglePatternCase.UseAsPattern (NoSinglePatternCase.FixOrFallback NoSinglePatternCase.CreateNewLet NoSinglePatternCase.Fail) -> NoSinglePatternCase.FixOrFallback NoSinglePatternCase.FallbackToArgument NoSinglePatternCase.Fail) -> NoSinglePatternCase.FixOrFallback NoSinglePatternCase.FallbackToArgument NoSinglePatternCase.Fail"},{"name":"butIfNoLetExists","comment":" If no `let` block exists to destructure in, choose some other behavior\ninstead.\n","type":"a -> (NoSinglePatternCase.FixOrFallback NoSinglePatternCase.CreateNewLet a -> NoSinglePatternCase.FixOrFallback (NoSinglePatternCase.FallbackToExistingLet a) NoSinglePatternCase.Fail) -> NoSinglePatternCase.FixOrFallback (NoSinglePatternCase.FallbackToExistingLet a) NoSinglePatternCase.Fail"},{"name":"createNewLetInstead","comment":" Choose to create a `let` block when none exists, instead of failing.\n","type":"NoSinglePatternCase.FixOrFallback NoSinglePatternCase.CreateNewLet NoSinglePatternCase.Fail"},{"name":"creatingNewLetIfNecessary","comment":" Choose to create a new `let` block to destructure in if none exists in\nscope.\n","type":"NoSinglePatternCase.FixOrFallback NoSinglePatternCase.CreateNewLet a"},{"name":"fail","comment":" Choose to fail at generating a fix.\n","type":"NoSinglePatternCase.FixOrFallback fix NoSinglePatternCase.Fail"},{"name":"fixInArgument","comment":" Always fix by destructuring in the argument. This will use `as` patterns if\nnecessary. If the argument cannot be destructured in, no fix will be generated.\n\nFor example:\n\n    f1 o =\n        case o of\n            Opaque i ->\n                i\n\n    f2 o =\n        let\n            x =\n                someFunc o\n        in\n        case o of\n            Opaque i ->\n                i + x\n\n    f3 { recordField } =\n        case recordField of\n            Opaque i ->\n                i\n\nwill be fixed to:\n\n    f1 (Opaque i) =\n        i\n\n    f2 ((Opaque i) as o) =\n        let\n            x =\n                someFunc o\n        in\n        i + x\n\n    f3 { recordField } =\n        case recordField of\n            Opaque i ->\n                i\n\nUse [`ifAsPatternRequired`](#ifAsPatternRequired) and\n[`ifArgumentNotDestructurable`](#ifArgumentNotDestructurable) to customize the\nbehavior in either of these cases.\n\n","type":"NoSinglePatternCase.Config NoSinglePatternCase.FixInArgument"},{"name":"fixInArgumentInstead","comment":" Fallback to destructuring in the argument instead of a `let` block.\n","type":"NoSinglePatternCase.FixOrFallback NoSinglePatternCase.UseAsPattern (NoSinglePatternCase.FixOrFallback NoSinglePatternCase.CreateNewLet NoSinglePatternCase.Fail) -> NoSinglePatternCase.FixOrFallback NoSinglePatternCase.FallbackToArgument NoSinglePatternCase.Fail"},{"name":"fixInLet","comment":" Always fix by destructuring in a `let` block, creating a new one if none\nexists.\nFor example:\n\n    f1 o =\n        case o of\n            Opaque i ->\n                i\n\n    f2 o =\n        let\n            x =\n                someFunc o\n        in\n        case o of\n            Opaque i ->\n                i + x\n\nwill be fixed to:\n\n    f1 o =\n        let\n            (Opaque i) =\n                o\n        in\n        i\n\n    f2 ((Opaque i) as o) =\n        let\n            x =\n                someFunc o\n\n            (Opaque i) =\n                o\n        in\n        i + x\n\nUse [`ifNoLetExists`](#ifNoLetExists) to customize the behavior in the case\nwhere no `let` block exists.\n\n","type":"NoSinglePatternCase.Config NoSinglePatternCase.FixInLet"},{"name":"fixInLetInstead","comment":" Fallback to destructuring in a `let` block instead of the argument.\n","type":"NoSinglePatternCase.FixOrFallback NoSinglePatternCase.CreateNewLet a -> NoSinglePatternCase.FixOrFallback (NoSinglePatternCase.FallbackToExistingLet a) NoSinglePatternCase.Fail"},{"name":"ifArgumentNotDestructurable","comment":" Specify what to do if the argument cannot be destructured at, e.g.\n\n    f { recordField } =\n        case recordField of\n            Opaque i ->\n                i\n\nAvailable options are [`fixInLetInstead`](#fixInLetInstead) or [`fail`](#fail)\n(this latter is the default), e.g.\n\n    c1 =\n        fixInArgument\n            |> ifArgumentNotDestructurable\n                (fixInLetInstead creatingNewLetIfNecessary)\n\n    c2 =\n        fixInArgument\n            |> ifArgumentNotDestructurable\n                (fixInLetInstead\n                    |> butIfNoLetExists fail\n                )\n\n","type":"NoSinglePatternCase.FixOrFallback (NoSinglePatternCase.FallbackToExistingLet (NoSinglePatternCase.FixOrFallback NoSinglePatternCase.Fail NoSinglePatternCase.Fail)) NoSinglePatternCase.Fail -> NoSinglePatternCase.Config NoSinglePatternCase.FixInArgument -> NoSinglePatternCase.Config NoSinglePatternCase.FixInArgument"},{"name":"ifAsPatternRequired","comment":" Choose different behavior if an `as` pattern would be required to\ndestructure in the argument, e.g.\n\n    f o =\n        let\n            x =\n                someFunc o\n        in\n        case o of\n            Opaque i ->\n                i + x\n\nAvailable options are [`fixInLetInstead`](#fixInLetInstead) or [`fail`](#fail),\ne.g.\n\n    c1 =\n        fixInArgument\n            |> ifAsPatternRequired fail\n\n    c2 =\n        fixInArgument\n            |> ifAsPatternRequired\n                (fixInLetInstead creatingNewLetIfNecessary)\n\n    c3 =\n        fixInArgument\n            |> ifAsPatternRequired\n                (fixInLetInstead\n                    |> butIfNoLetExists fail\n                )\n\n    c4 =\n        fixInArgument\n            |> ifAsPatternRequired\n                (fixInLetInstead\n                    |> butIfNoLetExists useAsPatternInstead\n                )\n\n","type":"NoSinglePatternCase.FixOrFallback (NoSinglePatternCase.FallbackToExistingLet (NoSinglePatternCase.FixOrFallback NoSinglePatternCase.UseAsPattern NoSinglePatternCase.Fail)) NoSinglePatternCase.Fail -> NoSinglePatternCase.Config NoSinglePatternCase.FixInArgument -> NoSinglePatternCase.Config NoSinglePatternCase.FixInArgument"},{"name":"ifNoLetExists","comment":" Specify what to do it no `let` block exists in scope, instead of creating a\nnew one.\n\nAvailable options are [`fixInArgumentInstead`](#fixInArgumentInstead) or\n[`fail`](#fail), e.g.\n\n    c1 =\n        fixInLet\n            |> ifNoLetExists fail\n\n    c2 =\n        fixInLet\n            |> ifNoLetExists\n                (fixInArgumentInstead usingAsPatternIfNecessary)\n\n    c3 =\n        fixInLet\n            |> ifNoLetExists\n                (fixInArgumentInstead\n                    |> butIfAsPatternRequired fail\n                )\n\n    c4 =\n        fixInLet\n            |> ifNoLetExists\n                (fixInArgumentInstead\n                    |> butIfAsPatternRequired createNewLetInstead\n                )\n\n","type":"NoSinglePatternCase.FixOrFallback NoSinglePatternCase.FallbackToArgument NoSinglePatternCase.Fail -> NoSinglePatternCase.Config NoSinglePatternCase.FixInLet -> NoSinglePatternCase.Config NoSinglePatternCase.FixInLet"},{"name":"resolveNameClashWithSeparateLet","comment":" Change the default behavior to instead resolve name clashes by creating a\nseparate `let` block. For example:\n\n    f o =\n        let\n            j i =\n                i + 1\n        in\n        case o of\n            Opaque i ->\n                j i\n\ninstead of generating an error with no automatic fix, will be automatically\nfixed to:\n\n    f o =\n        let\n            j i =\n                i + 1\n        in\n        let\n            (Opaque i) =\n                o\n        in\n        j i\n\n","type":"NoSinglePatternCase.Config fixBy -> NoSinglePatternCase.Config fixBy"},{"name":"rule","comment":" Reports single-pattern case expressions, which may be written more concisely\nor removed entirely.\n\n    config =\n        [ NoSinglePatternCase.rule NoSinglePatternCase.fixInArgument ]\n\nSee [`Config`](#Config) for configuration details.\n\n\n## Fail\n\nSingle-pattern case expressions for destructuring are not allowed, as:\n\n    type Opaque\n        = Opaque Int\n\n    unpack : Opaque -> Int\n    unpack o =\n        case o of\n            Opaque i ->\n                i\n\nmay instead be written more concisely, for example as\n\n    unpack : Opaque -> Int\n    unpack (Opaque i) =\n        i\n\nSimilarly, single-pattern case expressions that ase not used for destructuring\nare not allowed, as:\n\n    type AOrB\n        = A\n        | B\n\n    pointless : AOrB -> Bool\n    pointless aOrB =\n        case aOrB of\n            _ ->\n                True\n\nmay instead be written more concisely, for example as\n\n    pointless : AOrB -> Bool\n    pointless _ =\n        True\n\nor\n\n    pointless : AOrB -> Bool\n    pointless =\n        always True\n\n\n## Success\n\nAny case expression with more than one pattern match will not be reported.\nConsider using [`jfmengels/elm-review-simplify`](https://package.elm-lang.org/packages/jfmengels/elm-review-simplify/latest)\nto detect unnecessary multi-pattern cases.\n\n\n## When (not) to enable this rule\n\nThis rule is useful if you prefer destructuring in function/lambda arguments or\n`let` bindings, rather than in a single-pattern case.\n\nThis rule is not useful if you prefer the more verbose style.\n\n\n## Try it out\n\nYou can try this rule out by running the following command:\n\n```bash\nelm-review --template SiriusStarr/elm-review-no-single-pattern-case/example --rules NoSinglePatternCase\n```\n\n","type":"NoSinglePatternCase.Config fixBy -> Review.Rule.Rule"},{"name":"useAsPatternInstead","comment":" Choose to use an `as` pattern to destructure in the argument if necessary.\n","type":"NoSinglePatternCase.FixOrFallback NoSinglePatternCase.UseAsPattern a"},{"name":"usingAsPatternIfNecessary","comment":" Choose to use an `as` pattern to destructure in the argument if necessary.\n","type":"NoSinglePatternCase.FixOrFallback NoSinglePatternCase.UseAsPattern (NoSinglePatternCase.FixOrFallback NoSinglePatternCase.CreateNewLet NoSinglePatternCase.Fail)"}],"binops":[]}]